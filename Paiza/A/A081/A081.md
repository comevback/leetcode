# A081:カードの撹拌

<https://paiza.jp/student/challenges/718/retry>

あなたは、あるゲームのために 1 から N までの数が各 2 枚ずつ含まれたカードの山をシャッフルしようとしています。

ここで、シャッフルが不十分だと公平にゲームを行うことができなくなってしまうため、どの程度シャッフルされたかを表す数値を攪拌度と定義し、その値を計算することにしました。
攪拌度は各 1 ≦ x ≦ N について以下の結果の総和として求まります。

・x が書かれた 2 枚のカードの間に存在する、x 以外の整数が書かれたカードの枚数

シャッフル後のカードの並びが与えられるので、攪拌度を求めるプログラムを作成してください。

![img](http://paiza.s3.amazonaws.com/problem/img/718/img.png)

入力される値
入力は次のフォーマットで与えられます。

N
A_1
A_2
...
A_{2N}

・1 行目には、何種類の数字があるかを表す整数 N が与えられます。
・1 + i 行目 (1 ≦ i ≦ 2N) には、シャッフル後の上から i 番目のカードの数を表す整数 N が与えられます。
・入力は合計で 1 + 2N 行となり、入力値最終行の末尾に改行が 1 つ入ります。

文字列は標準入力から渡されます。標準入力からの値取得方法はこちらをご確認ください
期待する出力
・与えられたカードの並びの攪拌度を表す整数を出力してください。
・ただし、出力が 32 bit 整数に収まるとは限らないことに注意してください。
・また、出力最終行の末尾に改行を入れ、余計な文字、空行を含んではいけません。
条件
すべてのテストケースにおいて、以下の条件をみたします。
・1 ≦ N ≦ 100,000
・1 ≦ A_i ≦ N (1 ≦ i ≦ 2N)

言語別実行時間制限の詳細は こちら をご確認ください。

```
入力例1
3
1
2
1
2
3
3
```
```
出力例1
2
```
```
入力例2
3
2
2
1
1
3
3
```
```
出力例2
0
```
```
入力例3
5
3
1
4
1
5
2
2
5
4
3
```
```
出力例3
16
```

---

# Code
```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
)

func main() {
	var cardType int
	fmt.Scan(&cardType)                             // 从标准输入读取卡片类型的数量
	times := cardType * 2                           // 计算需要读取的卡片总数（每种类型2张）
	index := 1                                      // 用于记录当前卡片的索引位置
	var cardMap map[int][]int = make(map[int][]int) // 创建一个映射来存储每种类型的卡片和它们的索引位置
	sum := 0                                        // 用于累加结果

	scanner := bufio.NewScanner(os.Stdin) // 创建一个新的Scanner对象
	for scanner.Scan() {                  // 循环读取标准输入
		str := scanner.Text()       // 获取当前行的文本
		num, _ := strconv.Atoi(str) // 将读取的文本转换为整数

		cardMap[num] = append(cardMap[num], index) // 将当前卡片的索引添加到对应类型的切片中

		index += 1 // 索引递增
		times -= 1 // 减少剩余需要读取的次数
		if times < 1 {
			break // 如果已读取足够的卡片，退出循环
		}
	}

	for _, value := range cardMap { // 遍历每种卡片类型的索引列表
		add := value[1] - value[0] - 1 // 计算两张同类型卡片之间的间隔数
		sum += add                     // 累加间隔数到总和
	}

	fmt.Println(sum) // 输出所有间隔数的总和
}
```