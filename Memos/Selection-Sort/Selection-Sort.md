# Selection Sort O(n^2)-O(1)

选择排序是一种简单直观的比较排序算法。它的基本思想非常简单：不断地选择剩余元素中的最小者，将其与序列的前端进行交换，从而逐步确定元素的最终位置。选择排序是不稳定的排序方法，但它的代码实现简单，特点明显，易于理解和实施。下面是关于选择排序的详细总结：

### 工作原理
1. **开始状态**：整个数组是未排序的。
2. **第一步**：从未排序的部分找到最小的元素，然后将其与数组的第一个元素交换位置（如果第一个元素就是最小的，则自身与自身交换）。
3. **后续步骤**：从剩下的未排序部分继续这个过程，将最小的元素与未排序部分的第一个元素交换。
4. **重复过程**：重复上述过程，每次迭代中未排序部分减少一个元素，已排序部分增加一个元素，直到没有任何未排序的元素。

### 特性
- **时间复杂度**：选择排序的平均时间复杂度和最坏时间复杂度均为 \(O(n^2)\)，其中 \(n\) 是数组的长度。这是因为无论数组的初始状态如何，算法都会执行一个双重循环，每次找到未排序部分的最小值。
- **空间复杂度**：\(O(1)\)，因为选择排序是一种原地排序算法，除了输入数组外，只需要固定的额外空间（用于交换）。
- **稳定性**：选择排序是不稳定的排序算法。在多个相等的元素的数组中，相等元素的相对位置可能在排序过程中改变。
- **适用场景**：由于其较高的时间复杂度，选择排序通常不适用于元素数量较大的数组。它比较适合小规模数据的排序。

### 示例代码（Go语言实现）
```go
package main

import "fmt"

func main() {
	var nums []int = []int{1, 2, 5, 6, 2, 7, 9, 5, 3, 1}
	SelectionSort(nums)
	fmt.Println(nums)
}

// SelectionSort 选择排序 O(n^2) - O(1)
func SelectionSort(nums []int) {
	for i := 0; i < len(nums); i++ {
		for j := i + 1; j < len(nums); j++ {
			if nums[j] < nums[i] {
				nums[i], nums[j] = nums[j], nums[i]
			}
		}
	}
}
```

### 总结
选择排序由于其 \(O(n^2)\) 的时间复杂度，在处理大数据集时不够高效，但它的简单和直观使它成为了教学和了解基本排序算法的良好工具。此外，选择排序的交换操作次数相对较少，这可能在某些交换成本特别高的场景中显得有优势。尽管存在缺点，了解并实现选择排序仍是学习更复杂排序算法之前的重要步骤。